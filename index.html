<!doctype html>
<html>
  <head>
    <meta http-equiv="origin-trial" content="AspvaSU7F1Gbpa8q9JRNRNXFF+0+77C1xkxf1hkzJCrBI7Mmt/eG25QXLBn7lfzPsgrN5next8ZtIiCeGs6R4w8AAABleyJvcmlnaW4iOiJodHRwczovL2V4b2tpdC5vcmc6NDQzIiwiZmVhdHVyZSI6IldlYlhSRGV2aWNlTTc2IiwiZXhwaXJ5IjoxNTcxMTEyNjU0LCJpc1N1YmRvbWFpbiI6dHJ1ZX0=">
    <style>
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  /* background-color: #000;
  color: #F5F5F5; */
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;
  font-size: 15px;
}
.body {
  display: flex;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}
.body.fullscreen .header,
.body.fullscreen .sidebar,
.body.fullscreen .tools,
.body.fullscreen .iframe-buttons
{
  display: none;
}
.body.fullscreen .iframe-wrapper {
  margin-top: 0;
}
header {
  position: absolute;
  display: flex;
  top: 0;
  left: 0;
  width: 100vw;
  height: 50px;
  background-color: #FFF;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
  align-items: center;
  user-select: none;
  z-index: 1;
}
.main-selector {
  outline: none;
}
.main-selector:hover .target,
.main-selector .options .option:hover
{
  background-color: #42a5f5;
  color: #FFF;
}
.main-selector:active .target,
.main-selector.open .target,
.main-selector .options .option:active,
.main-selector .options .option.open
{
  background-color: #1e88e5;
  color: #FFF;
}
.main-selector:hover .target .icon,
.main-selector.open .target .icon
{
  filter: invert(1);
}
.main-selector .target .icon {
  width: 50px;
  height: 50px;
  margin: 0 20px;
}
.main-selector .options {
  display: flex;
  position: absolute;
  top: 50px;
  left: 0;
  width: 300px;
  background-color: #FFF;
  color: #000;
  flex-direction: column;
}
.main-selector .options .option {
  padding: 15px;
}
.main-selector:not(.open) .options {
  display: none;
}
header nav {
  display: flex;
  height: 100%;
  padding: 0 10px;
  letter-spacing: 0.9px;
  align-items: center;
}
header nav span {
  display: flex;
  height: 30px;
  padding: 10px;
  border-radius: 4px;
  align-items: center;
  text-transform: uppercase;
}
header nav.selected span {
  background-color: #5c6bc0;
  color: #FFF;
  cursor: default;
}
header nav:not(.selected):not([disabled]):hover {
  cursor: pointer;
}
header nav:not(.selected):hover span {
  background-color: #EEE;
}
header:not(.main-2) .channel-select,
header:not(.main-3) .parcel-display
{
  display: none;
}
.channel-select {
  display: flex;
  position: relative;
  align-items: center;
}
.channel-select input[type=text] {
  height: 50px;
  border-radius: 0;
}
.parcel-display {
  display: flex;
}
.channels-content {
  display: flex;
  position: absolute;
  top: 50px;
  left: 0;
  right: 0;
  flex-direction: column;
  background-color: #FFF;
}
.channels-content .a-channel {
  display: flex;
  padding: 5px;
  align-items: center;
  cursor: pointer;
}
.channels-content .a-channel:hover {
  background-color: #EEE;
}
.channels-content .a-channel:hover i {
  background-color: #000;
  color: #FFF;
}
.channels-content .a-channel i {
  display: flex;
  height: 50px;
  width: 50px;
  margin-right: 10px;
  background-color: #EEE;
  border-radius: 5px;
  font-size: 16px;
  justify-content: center;
  align-items: center;
}
.parcel-create,
.parcel-edit
{
  display: flex;
}
.parcel-create:not(.open),
.parcel-edit:not(.open)
{
  display: none;
}
.details-content h1,
.details-content h2,
.details-content h3,
.details-content h4,
.details-content h5,
.details-content h6,
.details-content p,
.details-content .multibutton
{
  margin: 15px 0;
  padding: 0 20px;
}
h1, h2, h3, h4, h5, h6, p {
  font-weight: inherit;
}
.screenshot-image {
  width: 100%;
}
.iframe-wrapper {
  position: relative;
  display: flex;
  margin-top: 50px;
  flex: 1;
  background-color: #000;
}
.tabs {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}
.tabs .tab {
  display: inline-flex;
  margin: 5px 5px;
  padding: 5px 10px;
  background-color: #D8D8D8;
  border-radius: 4px;
  color: #000;
  align-items: center;
}
.tabs .tab .text {
  margin-right: 10px;
  align-items: center;
}
.tabs .tab .close-x {
  display: flex;
  width: 20px;
  height: 20px;
  background-color: #ef5350;
  color: #FFF;
  justify-content: center;
  align-items: center;
}
canvas {
  width: 100% !important;
  height: 100% !important;
  /* background-color: #f8f8f8; */
  outline: none;
}
a {
  color: #AAA;
  text-decoration: none;
}
a:hover {
  color: #42a5f5;
}
a:active {
  color: #1976d2;
}
.tools {
  display: flex;
  position: absolute;
  top: 60px;
  left: 10px;
}
.tools > .tool {
  display: flex;
  width: 30px;
  height: 30px;
  justify-content: center;
  align-items: center;
  background-color: #EEE;
  font-size: 16px;
  /* color: #000; */
  cursor: pointer;
}
.tools > .tool:hover {
  background-color: #42a5f5;
  color: #FFF;
}
.tools > .tool:active, .tools > .tool.open {
  background-color: #1e88e5;
  color: #FFF;
}
.chat {
  position: absolute;
  bottom: 30px;
  left: 0;
  width: 400px;
  display: flex;
  flex-direction: column;
  pointer-events: none;
}
.chat > .messages {
  display: flex;
  flex-direction: column;
  padding: 7px 14px;
  background-color: rgba(0, 0, 0, 0.5);
  border-radius: 8px;
  color: #FFF;
  pointer-events: all;
}
.chat > .messages:empty {
  display: none;
}
.chat > .input {
  width: 100%;
  /* background-color: transparent; */
  background-color: rgba(50, 50, 50, 0.5);
  color: #FFF;
  pointer-events: all;
}
.chat > .input:not(.open) {
  visibility: hidden;
}
.save-dialog {
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 50px;
  left: 0;
  width: 300px;
  padding: 30px;
  background-color: #FFF;
}
.save-dialog:not(.open) {
  display: none;
}
.iframe-buttons {
  position: absolute;
  right: 330px;
  bottom: 30px;
}
.code-buttons {
  position: absolute;
  right: 30px;
  bottom: 30px;
  display: flex;
}
.multibutton {
  display: flex;
}
.multibutton .button:not(.first) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.multibutton .button:not(.last) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.button {
  display: inline-flex;
  margin-right: 5px;
  padding: 7px 14px;
  border: 2px solid;
  border-radius: 100px;
  color: #5c6bc0;
  font-size: 13px;
  outline: none
}
/* .button:not(:last-child) {
  margin-right: 20px;
} */
.button:not([disabled]):hover {
  background-color: #5c6bc0;
  border-color: #5c6bc0;
  color: #FFF;
  cursor: pointer;
}
.button[disabled] {
  color: #b71c1c;
}
#code-header:not(.open),
#code-button:not(.open) .opened-text,
#code-button.open .closed-text
{
  display: none;
}
.coming-soon {
  color: #ccc;
}
.coming-soon-sub {
  font-size: 10px;
  display: block;
}
.header-link {
  color: #666;
}
.code-header {
  position: absolute;
  top: 50px;
  right: 0;
  display: flex;
  align-items: center;
  width: 600px;
  height: 32px;
  padding: 5px;
  font-size: 13px;
  color: #4caf50;
  background-color: #f2f3f5;
}
.sidebar {
  /* display: flex; */
  margin-top: 50px;
  width: 300px;
  background-color: #FFF;
}
.sidebar .content-tabs, .sidebar .content-tabs .content-tab {
  background-color: #CCC;
}
.sidebar .content-tabs .content-tab {
  display: flex;
  position: relative;
  width: 50px;
  height: 50px;
  justify-content: center;
  align-items: center;
  font-size: 16px;
  color: #333;
  cursor: pointer;
}
.sidebar .content-tabs .content-tab:hover {
  background-color: #EEE;
  color: #000;
}
.sidebar .content-tabs .content-tab.open {
  background-color: #FFF;
  color: #5c6bc0;
}
.sidebar .content-tabs .content-tab .sub {
  display: flex;
  position: absolute;
  width: 100px;
  height: 50px;
  left: -100px;
  background-color: #333;
  color: #FFF;
  justify-content: center;
  align-items: center;
  visibility: hidden;
}
.sidebar .content-tabs .content-tab:hover .sub {
  visibility: visible;
}
.sidebar .content {
  flex: 1;
  overflow-y: auto;
}
.sidebar .content:not(.open) {
  display: none;
}
.site-urls-content .a-site,
.avatar-models-content .a-avatar,
.prefabs-content .a-prefab,
.inventory-content .a-file
{
  display: flex;
  position: relative;
  padding: 5px 0;
  cursor: pointer;
  overflow: hidden;
}
.site-urls-content .a-site img,
.avatar-models-content .a-avatar img,
.prefabs-content .a-prefab img,
.inventory-content .a-file i
{
  display: flex;
  width: 80px;
  height: 80px;
  margin-right: 10px;
  font-size: 50px;
  justify-content: center;
  align-items: center;
}
.site-urls-content .a-site img:not([src]),
.avatar-models-content .a-avatar img:not([src]),
.prefabs-content .a-prefab img:not([src]) {
  visibility: hidden;
}
.site-urls-content .a-site .wrap {
  flex: 1;
  overflow: hidden;
}
.site-urls-content .a-site .url {
  color: #666;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
.prefabs-content .a-prefab .wrap {
  flex: 1;
  overflow: hidden;
}
.site-urls-content > .wrap {
  display: flex;
}
.site-urls-content input[type=text],
.avatar-models-content input[type=text],
.prefabs-content input[type=text]
{
  width: 100%;
  margin: 0;
  padding: 15px;
  border-radius: 0;
}
.site-urls-content .input-button {
  display: flex;
  width: 48px;
  height: 48px;
  background-color: #CCC;
  color: #333;
  justify-content: center;
  align-items: center;
  cursor: pointer;
}
.site-urls-content .input-button:hover {
  background-color: #5c6bc0;
  color: #FFF;
}
.site-urls-content .input-button:active {
  background-color: #3949ab;
  color: #FFF;
}
.site-urls-content .a-site .wrap .label {
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
.site-urls-content .a-site .overlay,
.avatar-models-content .a-avatar .overlay,
.prefabs-content .a-prefab .overlay,
.inventory-content .a-file .overlay
{
  display: flex;
  position: absolute;
  top: -3px;
  bottom: -3px;
  left: 0;
  right: 0;
  padding: 10px;
  background-image: linear-gradient(to right, transparent, #FFF 50%);
  justify-content: flex-end;
  align-items: center;
  visibility: hidden;
}
.site-urls-content .a-site:hover .overlay,
.avatar-models-content .a-avatar:hover .overlay,
.prefabs-content .a-prefab:hover .overlay,
.inventory-content .a-file:hover .overlay
{
  visibility: visible;
}
.prefabs-content .end {
  width: 100%;
  height: 1px;
}
.selected-object-details,
.avatar-details,
/* .parcel-details, */
.placeholder-details
{
  display: none;
}
.selected-object-details.open,
.avatar-details.open,
/* .parcel-details.open, */
.selected-object-details:not(.open) + .avatar-details:not(.open) /* + .parcel-details:not(.open) */ + .placeholder-details
{
  display: block;
}
.switch-wrap {
  display: flex;
  align-items: center;
  color: #AAA;
  cursor: pointer;
  user-select: none;
  // transition: all 0.3s cubic-bezier(0, 1, 0, 1);
}
.switch {
  position: relative;
  margin-right: 5px;
  padding: 2px;
  border: 2px solid #AAA;
  border-radius: 100px;
  cursor: pointer;
  // transition: all 0.3s cubic-bezier(0, 1, 0, 1);
}
.switch::before {
  display: block;
  position: relative;
  height: 12px;
  width: 24px;
  background-color: #EEE;
  border-radius: 100px;
  content: '';
}
.switch::after {
  display: block;
  position: absolute;
  top: 2px;
  left: 2px;
  height: 12px;
  width: 12px;
  background-color: #AAA;
  border-radius: 100px;
  content: '';
  // transition: all 0.3s cubic-bezier(0, 1, 0, 1);
}
.switch-wrap.on {
  color: #5c6bc0;
}
.switch-wrap.on .switch {
  border-color: #5c6bc0;
}
/* .switch.on::before {
  background-color: #BBB;
} */
.switch-wrap.on .switch::after {
  left: 14px;
  background-color: #5c6bc0;
}
input[type=button] {
  display: block;
}
.code {
  width: 100%;
  height: 100%;
  font-family: monospace;
  font-size: 14px;
  border: 0;
  outline: none;
}
.minibuttons {
  position: relative;
}
.minibuttons button {
  position: absolute;
  bottom: 0;
}
.minibuttons button + button {
  left: 50px;
}
.user-code {
  display: none;
}
input[type=text] {
  width: 160px;
  /* margin: 0 20px; */
  padding: 7px 14px;
  background-color: #f2f3f5;
  border: 0;
  border-radius: 8px;
  font-family: inherit;
  font-size: inherit;
  outline: none;
}

/* account.css */

input[type=email],
input[type=text]
{
  margin-right: 10px;
  padding: 7px 14px;
  background-color: #f2f3f5;
  border: 0;
  border-radius: 8px;
  font-family: inherit;
  font-size: inherit;
  outline: none;
}

header > .login-form {
  display: flex;
  margin-left: auto;
}

body.logging-in .login-form,
header > .login-form:not(.phase-1) > .phase-1-content,
header > .login-form:not(.phase-2) > .phase-2-content,
header > .login-form:not(.phase-3) > .phase-3-content,
header > .login-form.phase-1 > .phaseless-content,
header > .login-form.phase-2 > .phaseless-content,
header > .login-form.phase-3 > .phaseless-content
{
  display: none;
}

.login-form .phase-content {
  display: flex;
  align-items: center;
}
.login-form .phase-content .login-error
{
  margin-right: 15px;
  font-weight: 600;
}
.login-form .phase-content .user-button {
  display: flex;
  height: 30px;
  margin-right: 10px;
  padding: 3px 10px;
  background-color: #f2f3f5;
  border: 0;
  border-radius: 8px;
  align-items: center;
  cursor: pointer;
}
.login-form .phase-content .user-button:hover,
.login-form .phase-content .user-button.open {
  background-color: #CCC;
}
.login-form .phase-content .user-button > img {
  width: 20px;
  height: 20px;
  margin-right: 5px;
}
.login-form .phase-content .user-button > .name {
  display: flex;
  height: 100%;
  font-weight: 600;
  align-items: center;
}
.login-form .phase-content .login-notice {
  color: #4caf50;
}
.login-form .phase-content .login-error {
  color: #e53935;
}
.login-form .phaseless-content {
  padding: 0 30px;
}
    </style>
    <script src="https://kit.fontawesome.com/0735724151.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <div class=body>
      <header class="header main-1" id=header>
        <div class=main-selector tabindex=-1 id=main-selector>
          <nav class=target>
            <img src="logo.svg" class="icon">
            <i class="fas fa-chevron-down"></i>
          </nav>
          <div class=options>
            <nav class="option open">Home</nav>
            <nav class=option>Multiplayer</nav>
            <nav class=option>Land</nav>
          </div>
        </div>

        <div class=channel-select>
          <div class=channels-content id=channels-content style="display: none"></div>
          <input type=text placeholder="channel name" id=channel-input>
          <div class=multibutton>
            <nav class="button first last" disabled id=connect-button>Create</nav>
            <nav class="button first last" id=disconnect-button style="display: none">Disconnect</nav>
          </div>
        </div>

        <div class=parcel-display>
          <div class=parcel-create id=parcel-create>
            <div class=multibutton>
              <nav class="button first last" id=create-parcel-button>Claim parcel</nav>
            </div>
          </div>
          <div class=parcel-edit id=parcel-edit>
            <input type=text placeholder="parcel name" id=parcel-name-input>
            <div class=multibutton>
              <nav class="button first last" id=save-parcel-button style="display: none">Save</nav>
            </div>
            <div class=multibutton>
              <nav class="button first last" id=edit-parcel-button>Edit parcel</nav>
            </div>
            <div class=multibutton>
              <nav class="button first last" id=stop-editing-button style="display: none">Stop editing</nav>
            </div>
          </div>
        </div>

        <!-- <form class="login-form phase-1" id=login-form>
          <div class=phase-content>
            <div class=login-notice id=login-notice></div>
            <div class=login-error id=login-error></div>
          </div>
          <div class="phase-content phase-1-content">
            <input type=email placeholder="your@email.com" id=login-email>
            <input type=submit value="Log in" class="button highlight">
          </div>
          <div class="phase-content phase-2-content">
            <input type=text placeholder="Verification code" id=login-verification-code>
            <input type=submit value="Verify" class="button highlight">
          </div>
          <div class="phase-content phase-3-content">
            <button class=user-button id=user-button>
              <img src="exobot.png">
              <span class=name id=login-email-static>a@modules.io</span>
            </button>
            <input type=submit value="Log out" class="button highlight">
          </div>
          <div class="phase-content phaseless-content">
            <div>Working...</div>
          </div>
        </form> -->
      </header>

      <div class=iframe-wrapper id=iframe-wrapper></div>
      <!-- <div class=tools>
        <nav class="tool open"><i class="fal fa-video"></i></nav>
        <nav class=tool><i class="fal fa-mouse-pointer"></i></nav>
        <nav class=tool><i class="fal fa-arrows"></i></nav>
        <nav class=tool><i class="fal fa-vector-square"></i></nav>
      </div> -->
      <form class=chat id=chat>
        <div class=messages id=chat-messages></div>
        <input type=text class=input id=chat-input>
      </form>
      <form class=save-dialog id=save-dialog>
        <input type=text placeholder="Enter file name..." id=save-name-input>
        <input type=submit value="Save">
      </form>
      <!-- <div class="iframe-buttons multibutton">
        <a class="button first" id="enable-mic-button">Enable Mic</a>
        <a class="button first" id="disable-mic-button" disabled style="display: none;">Disable Mic</a>
        <a class="button" id="firstperson-button">Firstperson</a>
        <a class="button" id="thirdperson-button">Thirdperson</a>
        <a class="button last" id="enter-xr-button" style="display: none;">Enter XR</a>
        <a class="button last" id="no-xr-button" disabled style="display: none;">No XR</a>
      </div> -->

      <div class=sidebar>
        <label class="switch-wrap on" id=gpu-switch-wrap>
          <div class=switch id=gpu-switch></div>
          GPU pointcloud
        </label>
        <label class=switch-wrap id=cpu-switch-wrap>
          <div class=switch id=cpu-switch></div>
          CPU pointcloud
        </label>
        <label class=switch-wrap id=raycast-switch-wrap>
          <div class=switch id=raycast-switch></div>
          Raycast
        </label>
        <label class=switch-wrap id=voxels-switch-wrap>
          <div class=switch id=voxels-switch></div>
          Voxelization
        </label>
        <label class=switch-wrap id=voxel-texture-switch-wrap>
          <div class=switch id=voxel-texture-switch></div>
          Voxel texture
        </label>
        <label class="switch-wrap on" id=meshing-switch-wrap>
          <div class=switch id=meshing-switch></div>
          Meshing
        </label>
        <label class=switch-wrap id=meshing-texture-switch-wrap>
          <div class=switch id=meshing-texture-switch></div>
          Mesh texture
        </label>
      </div>
    </div>
    <script type=module>
import './three.js';
// import './BufferGeometryUtils.js';
// import './OutlineEffect.js';
import './OrbitControls.js';
// import './TransformControls.js';
import './Reflector.js';
// import './land.js';
// import './bmfont.js';

import ModelLoader from 'https://model-loader.exokit.org/model-loader.js';
import avatarModels from 'https://avatar-models.exokit.org/avatar-models.js';
import itemModels from 'https://item-models.exokit.org/item-models.js';

const worker = (() => {
  let cbs = [];
  const worker = new Worker('mc-worker.js');
  worker.onmessage = e => {
    const {data} = e;
    const {error, result} = data;
    cbs.shift()(error, result);
  };
  worker.onerror = err => {
    console.warn(err);
  };
  worker.request = (req, transfers) => new Promise((accept, reject) => {
    worker.postMessage(req, transfers);

    cbs.push((err, result) => {
      if (!err) {
        accept(result);
      } else {
        reject(err);
      }
    });
  });
  return worker;
})();

const parcelSize = 16;
const width = 10;
const height = 10;
const depth = 10;
const voxelSize = 0.1;
const potentialClearValue = -0.2;
const potentialSetValue = 0.7;

const _getPotentialIndex = (x, y, z) => x + y*(width+1)*(depth+1) + z*(width+1);
const _makePromise = () => {
  let accept, reject;
  const p = new Promise((a, r) => {
    accept = a;
    reject = r;
  });
  p.accept = accept;
  p.reject = reject;
  return p;
};

const localVector = new THREE.Vector3();
const localVector2 = new THREE.Vector3();
const localVector3 = new THREE.Vector3();
const localVector4 = new THREE.Vector3();
const localVector5 = new THREE.Vector3();
const localVector2D = new THREE.Vector2();
const localVector4D = new THREE.Vector4();
const localQuaternion = new THREE.Quaternion();
const localQuaternion2 = new THREE.Quaternion();
const localMatrix = new THREE.Matrix4();
const localEuler = new THREE.Euler();
const localRaycaster = new THREE.Raycaster();
const localColor = new THREE.Color();

const z180Quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);

const scene = new THREE.Scene();

// renderItems(scene);

const container = new THREE.Object3D();
scene.add(container);

const fov_y = 60;
const aspect = window.innerWidth / window.innerHeight;
const orthoDepth = 3;
const height_ortho = orthoDepth * 2 * Math.atan( fov_y*(Math.PI/180) / 2 );
const width_ortho  = height_ortho * aspect;
const camera = new THREE.PerspectiveCamera(fov_y, aspect, 0.1, 1000);
camera.position.y = 1.5;
camera.position.z = 0.5;
// camera.lookAt(new THREE.Vector3(0, 1, 0))

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 2);
directionalLight.position.set(0.5, 1, 0.5);
scene.add(directionalLight);

/* const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 4);
directionalLight2.position.set(-0.5, 1, -0.5);
scene.add(directionalLight2); */

function mod(a, n) {
  return ((a%n)+n)%n;
}
const floorMesh = (() => {
  const numTiles = 64;
  const numTiles2P1 = 2*numTiles+1;
  const planeBufferGeometry = new THREE.PlaneBufferGeometry(1, 1)
    .applyMatrix(localMatrix.makeScale(0.95, 0.95, 1))
    .applyMatrix(localMatrix.makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2)))
    .toNonIndexed();
  const numCoords = planeBufferGeometry.attributes.position.array.length;
  const numVerts = numCoords/3;
  const positions = new Float32Array(numCoords*numTiles2P1*numTiles2P1);
  const typesx = new Float32Array(numVerts*numTiles2P1*numTiles2P1);
  const typesz = new Float32Array(numVerts*numTiles2P1*numTiles2P1);
  let i = 0;
  for (let x = -numTiles; x <= numTiles; x++) {
    for (let z = -numTiles; z <= numTiles; z++) {
      const newPlaneBufferGeometry = planeBufferGeometry.clone()
        .applyMatrix(localMatrix.makeTranslation(x, 0, z));
      positions.set(newPlaneBufferGeometry.attributes.position.array, i * newPlaneBufferGeometry.attributes.position.array.length);
      let typex = 0;
      if (mod((x + parcelSize/2), parcelSize) === 0) {
        typex = 1/8;
      } else if (mod((x + parcelSize/2), parcelSize) === parcelSize-1) {
        typex = 2/8;
      }
      let typez = 0;
      if (mod((z + parcelSize/2), parcelSize) === 0) {
        typez = 1/8;
      } else if (mod((z + parcelSize/2), parcelSize) === parcelSize-1) {
        typez = 2/8;
      }
      for (let j = 0; j < numVerts; j++) {
        typesx[i*numVerts + j] = typex;
        typesz[i*numVerts + j] = typez;
      }
      i++;
    }
  }
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('typex', new THREE.BufferAttribute(typesx, 1));
  geometry.setAttribute('typez', new THREE.BufferAttribute(typesz, 1));
  const floorVsh = `
    // uniform float uAnimation;
    attribute float typex;
    attribute float typez;
    varying vec3 vPosition;
    varying float vTypex;
    varying float vTypez;
    varying float vDepth;
    void main() {
      // float radius = sqrt(position.x*position.x + position.z*position.z);
      vec3 p = vec3(position.x, position.y /*- (1.0 - uAnimation) * radius*/, position.z);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
      vPosition = position + vec3(0.5, 0.0, 0.5);
      vTypex = typex;
      vTypez = typez;
      vDepth = gl_Position.z / ${numTiles.toFixed(8)};
    }
  `;
  const floorFsh = `
    uniform vec4 uCurrentParcel;
    uniform vec4 uHoverParcel;
    uniform vec4 uSelectedParcel;
    uniform vec3 uSelectedColor;
    // uniform float uAnimation;
    varying vec3 vPosition;
    varying float vTypex;
    varying float vTypez;
    varying float vDepth;
    void main() {
      vec3 c;
      float a;
      if (
        vPosition.x >= uSelectedParcel.x &&
        vPosition.z >= uSelectedParcel.y &&
        vPosition.x <= uSelectedParcel.z &&
        vPosition.z <= uSelectedParcel.w
      ) {
        c = uSelectedColor;
      } else {
        c = vec3(0.5);
      }
      float add = 0.0;
      if (
        vPosition.x >= uHoverParcel.x &&
        vPosition.z >= uHoverParcel.y &&
        vPosition.x <= uHoverParcel.z &&
        vPosition.z <= uHoverParcel.w
      ) {
        add = 0.2;
      } else {
        vec3 f = fract(vPosition);
        if (vTypex >= 2.0/8.0) {
          if (f.x >= 0.8) {
            add = 0.2;
          }
        } else if (vTypex >= 1.0/8.0) {
          if (f.x <= 0.2) {
            add = 0.2;
          }
        }
        if (vTypez >= 2.0/8.0) {
          if (f.z >= 0.8) {
            add = 0.2;
          }
        } else if (vTypez >= 1.0/8.0) {
          if (f.z <= 0.2) {
            add = 0.2;
          }
        }
        /* if (
          vPosition.x >= uCurrentParcel.x &&
          vPosition.z >= uCurrentParcel.y &&
          vPosition.x <= uCurrentParcel.z &&
          vPosition.z <= uCurrentParcel.w
        ) {
          add = 0.2;
        } */
      }
      c += add;
      a = (1.0-vDepth)*0.5;
      gl_FragColor = vec4(c, a);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      /* uTex: {
        type: 't',
        value: new THREE.Texture(),
      }, */
      uCurrentParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uHoverParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uSelectedParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uSelectedColor: {
        type: 'c',
        value: new THREE.Color().setHex(0x29b6f6),
      },
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: floorVsh,
    fragmentShader: floorFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
container.add(floorMesh);

let renderingMirror = false;
const mirrorMesh = (() => {
  const mirrorWidth = 3;
  const mirrorHeight = 2;
  const geometry = new THREE.PlaneBufferGeometry(mirrorWidth, mirrorHeight)
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, 1, 0));
  const mesh = new THREE.Reflector(geometry, {
    clipBias: 0.003,
    textureWidth: 1024 * window.devicePixelRatio,
    textureHeight: 2048 * window.devicePixelRatio,
    color: 0x889999,
    backgroundColor: 0x000000,
    recursion: 1,
    transparent: true,
  });
  mesh.position.set(0, 0, -1);

  const borderMesh = new THREE.Mesh(
    new THREE.BoxBufferGeometry(mirrorWidth + 0.1, mirrorHeight + 0.1, 0.1)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 1, -0.1/2 - 0.01)),
    new THREE.MeshPhongMaterial({
      color: 0x5c6bc0,
    })
  );
  mesh.add(borderMesh);

  mesh.onBeforeRender2 = () => {
    renderingMirror = true;
  };
  mesh.onAfterRender2 = () => {
    renderingMirror = false;
  };

  return mesh;
})();
// container.add(mirrorMesh);

const boxMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(2, 2, 0.1);
  const material = new THREE.MeshPhongMaterial({
    color: 0x333333,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
boxMesh.position.y = 1;
boxMesh.position.z = -1;
container.add(boxMesh);

(async () => {
  const {url} = avatarModels[0];
  const src = `https://avatar-models.exokit.org/${url}`;
  const object = await ModelLoader.loadModelUrl(src);
  const model = object.scene;
  model.position.x = 0.5;
  model.position.z = 0.5;
  container.add(model);
})();
(async () => {
  const url = itemModels[927];
  const src = `https://item-models.exokit.org/glb/${url.replace(/\.fbx$/, '.glb')}`;
  const object = await ModelLoader.loadModelUrl(src);
  const model = object.scene;
  model.position.x = -0.5;
  // model.position.z = 0.5;
  container.add(model);
})();

const gpuSwitchWrap = document.getElementById('gpu-switch-wrap');
gpuSwitchWrap.addEventListener('click', () => {
  gpuSwitchWrap.classList.toggle('on');
  gpuParticlesMesh.visible = gpuSwitchWrap.classList.contains('on');
});
const cpuSwitchWrap = document.getElementById('cpu-switch-wrap');
cpuSwitchWrap.addEventListener('click', () => {
  cpuSwitchWrap.classList.toggle('on');
  particlesMesh.visible = cpuSwitchWrap.classList.contains('on');
});
const raycastSwitchWrap = document.getElementById('raycast-switch-wrap');
raycastSwitchWrap.addEventListener('click', () => {
  raycastSwitchWrap.classList.toggle('on');
  const enabled = raycastSwitchWrap.classList.contains('on');
  if (!enabled) {
    raycastMesh.visible = false;
  }
});
const voxelsSwitchWrap = document.getElementById('voxels-switch-wrap');
voxelsSwitchWrap.addEventListener('click', () => {
  voxelsSwitchWrap.classList.toggle('on');
  const enabled = voxelsSwitchWrap.classList.contains('on');
  for (let i = 0; i < xrChunker.chunks.length; i++) {
    const chunk = xrChunker.chunks[i];
    chunk.voxelsMesh.visible = enabled && !!chunk.potentialsTexture.image.data;
  }
});
const voxelTextureSwitchWrap = document.getElementById('voxel-texture-switch-wrap');
voxelTextureSwitchWrap.addEventListener('click', () => {
  voxelTextureSwitchWrap.classList.toggle('on');
  const enabled = voxelTextureSwitchWrap.classList.contains('on');
  for (let i = 0; i < xrChunker.chunks.length; i++) {
    xrChunker.chunks[i].voxelsMesh.material = enabled ? xrChunker.chunks[i].voxelsTexturedMaterial : xrChunker.chunks[i].voxelsMaterial;
  }
});
const meshingSwitchWrap = document.getElementById('meshing-switch-wrap');
meshingSwitchWrap.addEventListener('click', () => {
  meshingSwitchWrap.classList.toggle('on');
  const enabled = meshingSwitchWrap.classList.contains('on');
  for (let i = 0; i < xrChunker.chunks.length; i++) {
    const chunk = xrChunker.chunks[i];
    const {marchCubesMesh} = chunk;
    marchCubesMesh.visible = enabled && !!marchCubesMesh.geometry.attributes.position;
  }
});
const meshingTextureSwitchWrap = document.getElementById('meshing-texture-switch-wrap');
meshingTextureSwitchWrap.addEventListener('click', () => {
  meshingTextureSwitchWrap.classList.toggle('on');
  const enabled = meshingTextureSwitchWrap.classList.contains('on');
  for (let i = 0; i < xrChunker.chunks.length; i++) {
    xrChunker.chunks[i].marchCubesMesh.material = enabled ? xrChunker.chunks[i].marchCubesTexturedMaterial : marchCubesMaterial;
  }
});

const renderer = new THREE.WebGLRenderer({
  alpha: true,
  antialias: true,
});
// console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
renderer.getContext().canvas.addEventListener('webglcontextlost', e => {
  console.log('webglcontextlost', e);
  debugger;
});
const iframeWrapper = document.getElementById('iframe-wrapper');
iframeWrapper.appendChild(renderer.domElement);

const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
orbitControls.target.set(0, 1, 0);
orbitControls.screenSpacePanning = true;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const depthMaterial = (() => {
  const depthVsh = `
    // uniform float uAnimation;
    // attribute float typex;
    // varying vec3 vPosition;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    }
  `;
  const depthFsh = `
    uniform float uNear;
    uniform float uFar;

    vec4 EncodeFloatRGBA( float v ) {
      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
      enc = fract(enc);
      // enc -= enc.xyzw * vec4(1.0/255.0,1.0/255.0,1.0/255.0,1.0/255.0);
      return enc;
    }
    /* float DecodeFloatRGBA( vec4 rgba ) {
      return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
    } */
    // const float infinity = 1./0.;
    void main() {
      float originalZ = uNear + gl_FragCoord.z / gl_FragCoord.w * (uFar - uNear);
      // gl_FragColor = EncodeFloatRGBA(originalZ);

      float x = fract(originalZ);
      originalZ -= x;
      originalZ /= 255.0;
      float y = fract(originalZ);
      originalZ -= y;
      originalZ /= 255.0;
      float z = fract(originalZ);
      /* originalZ -= y;
      originalZ /= 255.0;
      float w = fract(originalZ);
      float w = 0.0;
      if (x == 0.0 && y == 0.0 && z == 0.0 && w == 0.0) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
      } else { */
        gl_FragColor = vec4(x, y, z, 0.0);
      // }
    }
  `;
  return new THREE.ShaderMaterial({
    uniforms: {
      uNear: {
        type: 'f',
        value: 0,
      },
      uFar: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: depthVsh,
    fragmentShader: depthFsh,
    // transparent: true,
  });
})();

const cameraSize = 512;
const cameraTarget = new THREE.WebGLRenderTarget(cameraSize, cameraSize, {
  minFilter: THREE.LinearFilter,
  magFilter: THREE.NearestFilter,
  format: THREE.RGBAFormat,
  // type: THREE.FloatType,
  depthBuffer: true,
  stencilBuffer: false,
});

const marchCubesTexSize = 2048;
const marchCubesTexTriangleSize = 64;
const marchCubesTexSquares = marchCubesTexSize/marchCubesTexTriangleSize;
const voxelsGeometry = (() => {
  const cubeGeometry = new THREE.BoxBufferGeometry(voxelSize, voxelSize, voxelSize)
    // .applyMatrix(localMatrix.makeTranslation(voxelSize/2, voxelSize/2, voxelSize/2))
    .toNonIndexed();
  const cubeBarycentrics = new Float32Array(cubeGeometry.attributes.position.array.length/3*4);
  for (let i = 0; i < cubeBarycentrics.length/(2*6); i++) {
    cubeBarycentrics[i*12] = 0;
    cubeBarycentrics[i*12+1] = 1;

    cubeBarycentrics[i*12+2] = 0;
    cubeBarycentrics[i*12+3] = 0;

    cubeBarycentrics[i*12+4] = 1;
    cubeBarycentrics[i*12+5] = 1;

    cubeBarycentrics[i*12+6] = 0;
    cubeBarycentrics[i*12+7] = 0;

    cubeBarycentrics[i*12+8] = 1;
    cubeBarycentrics[i*12+9] = 0;

    cubeBarycentrics[i*12+10] = 1;
    cubeBarycentrics[i*12+11] = 1;
  }
  cubeGeometry.setAttribute('barycentric', new THREE.BufferAttribute(cubeBarycentrics, 2));
  const positions = new Float32Array(cubeGeometry.attributes.position.array.length*width*height*depth);
  const barycentrics = new Float32Array(cubeGeometry.attributes.barycentric.array.length*width*height*depth);
  const coords = new Float32Array(cubeGeometry.attributes.position.array.length*width*height*depth);
  const positionCenters = new Float32Array(cubeGeometry.attributes.position.array.length*width*height*depth);
  let i = 0;
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      for (let z = 0; z < depth; z++) {
        const newCubeGeometry = cubeGeometry.clone()
          .applyMatrix(localMatrix.makeTranslation(x*voxelSize, y*voxelSize, z*voxelSize));
        positions.set(newCubeGeometry.attributes.position.array, i*newCubeGeometry.attributes.position.array.length);
        barycentrics.set(newCubeGeometry.attributes.barycentric.array, i*newCubeGeometry.attributes.barycentric.array.length);
        const offset = Float32Array.from([x, y, z]);
        for (let j = 0; j < newCubeGeometry.attributes.position.array.length/3; j++) {
          coords.set(offset, i*newCubeGeometry.attributes.position.array.length + j*3);
        }
        const center = Float32Array.from([x*voxelSize + 0.5*voxelSize, y*voxelSize + 0.5*voxelSize, z*voxelSize + 0.5*voxelSize]);
        for (let j = 0; j < newCubeGeometry.attributes.position.array.length/3; j++) {
          positionCenters.set(center, i*newCubeGeometry.attributes.position.array.length + j*3);
        }
        i++;
      }
    }
  }
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('barycentric', new THREE.BufferAttribute(barycentrics, 2));
  geometry.setAttribute('coord', new THREE.BufferAttribute(coords, 3));
  geometry.setAttribute('positionCenter', new THREE.BufferAttribute(positionCenters, 3));
  return geometry;
})();
const marchCubesMaterial = new THREE.ShaderMaterial({
  uniforms: {},
  vertexShader: `\
    attribute vec3 barycentric;
    varying vec3 vPosition;
    varying vec3 vBC;
    void main() {
      vBC = barycentric;
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      vPosition = modelViewPosition.xyz;
      gl_Position = projectionMatrix * modelViewPosition;
    }
  `,
  fragmentShader: `\
    uniform sampler2D uCameraTex;
    varying vec3 vPosition;
    varying vec3 vBC;

    vec3 color = vec3(0.984313725490196, 0.5490196078431373, 0.0);
    vec3 lightDirection = vec3(0.0, 0.0, 1.0);

    float edgeFactor() {
      vec3 d = fwidth(vBC);
      vec3 a3 = smoothstep(vec3(0.0), d*1.5, vBC);
      return min(min(a3.x, a3.y), a3.z);
    }

    void main() {
      float barycentricFactor = (0.2 + (1.0 - edgeFactor()) * 0.8);
      vec3 xTangent = dFdx( vPosition );
      vec3 yTangent = dFdy( vPosition );
      vec3 faceNormal = normalize( cross( xTangent, yTangent ) );
      float lightFactor = dot(faceNormal, lightDirection);
      gl_FragColor = vec4((0.5 + color * barycentricFactor) * lightFactor, 0.5 + barycentricFactor * 0.5);
      // gl_FragColor = vec4((0.5 + color * barycentricFactor) * lightFactor, 1.0);
    }
  `,
  // side: THREE.BackSide,
  /* polygonOffset: true,
  polygonOffsetFactor: -1,
  polygonOffsetUnits: -4, */
  transparent: true,
  // depthWrite: false,
  extensions: {
    derivatives: true,
  },
});
const marchCubesRenderMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uCameraTex: {
      type: 't',
      value: cameraTarget.texture,
    },
  },
  vertexShader: `\
    varying vec3 vScreenPosition;
    void main() {
      gl_Position = vec4((uv-0.5)*2.0, 0.0, 1.0);
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      vec4 projectionPosition = projectionMatrix * modelViewPosition;
      vScreenPosition = (projectionPosition.xyz/projectionPosition.w)/2.0+0.5;
    }
  `,
  fragmentShader: `\
    uniform sampler2D uCameraTex;
    varying vec3 vScreenPosition;

    void main() {
      vec2 uv = vScreenPosition.xy;
      gl_FragColor = texture2D(uCameraTex, uv);
      gl_FragColor.a = 1.0;
    }
  `,
  // side: THREE.BackSide,
  transparent: true,
  extensions: {
    derivatives: true,
  },
});
class XRRaycaster {
  constructor({width = colorTargetSize, height = colorTargetSize, renderer = new THREE.WebGLRenderer(), camera = new THREE.PerspectiveCamera()} = {}) {
    this.width = width;
    this.height = height;
    this.renderer = renderer;
    this.camera = camera;

    const colorTarget = new THREE.WebGLRenderTarget(width, height, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.NearestFilter,
      format: THREE.RGBAFormat,
      type: THREE.FloatType,
      depthBuffer: true,
      stencilBuffer: false,
    });
    colorTarget.fresh = false;
    colorTarget.freshPbuf = false;
    const colorTargetPbuf = new Float32Array(width*height*4); // encoded z depths
    this.colorTargetPbuf = colorTargetPbuf;
    const colorTargetCoordBuf = new Float32Array(width*height*3); // decoded xyz points
    this.colorTargetCoordBuf = colorTargetCoordBuf;
    colorTarget.update = newCamera => {
      if (!colorTarget.fresh || !camera.position.equals(newCamera.position) || !camera.quaternion.equals(newCamera.quaternion)) {
        camera.position.copy(newCamera.position);
        camera.quaternion.copy(newCamera.quaternion);
        _renderDepth(colorTarget, camera);
        colorTarget.fresh = true;
        colorTarget.freshPbuf = false;
      }
    };
    colorTarget.updatePbuf = async () => {
      if (!colorTarget.freshPbuf) {
        await new Promise((accept, reject) => {
          requestAnimationFrame(accept);
        });
        renderer.readRenderTargetPixels(colorTarget, 0, 0, width, height, colorTargetPbuf, 0);

        let index = 0;
        for (let x = 0; x < colorTargetSize; x++) {
          for (let y = 0; y < colorTargetSize; y++) {
            const xFactor = x / colorTargetSize;
            const yFactor = y / colorTargetSize;
            const px = Math.floor(xFactor * width);
            const py = Math.floor((1-yFactor) * height)-1;
            const z = DecodeFloatRGBA(colorTargetPbuf, (px * 4) + (py * colorTargetSize * 4));
            
            localRaycaster.setFromCamera(localVector2D.set(xFactor * 2 - 1, -yFactor * 2 + 1), camera);
            localVector.copy(localRaycaster.ray.origin)
              .add(localVector2.copy(localRaycaster.ray.direction).multiplyScalar(z))
              .toArray(colorTargetCoordBuf, index);
            index += 3;
          }
        }

        colorTarget.freshPbuf = true;
      }
    };
    this.colorTarget = colorTarget;
  }
  getPointCloudBuffer() {
    return this.colorTargetCoordBuf;
  }
  getDepthTexture() {
    return this.colorTarget.texture;
  }
  async raycast(xFactor, yFactor) {
    if (xFactor >= 0 && xFactor <= 1 && yFactor >= 0 && yFactor <= 1) {
      localRaycaster.setFromCamera(localVector2D.set(xFactor * 2 - 1, -yFactor * 2 + 1), camera);
      this.camera.position.copy(localRaycaster.ray.origin);
      this.camera.quaternion.setFromUnitVectors(localVector.set(0, 0, -1), localRaycaster.ray.direction);
      _renderDepth(this.colorTarget, this.camera);

      renderer.readRenderTargetPixels(this.colorTarget, 0, 0, 1, 1, this.colorTargetPbuf, 0);
      const z = DecodeFloatRGBA(this.colorTargetPbuf, 0);
      return localVector.copy(localRaycaster.ray.origin)
        .add(localVector2.copy(localRaycaster.ray.direction).multiplyScalar(z))
        .toArray();
    } else {
      return null;
    }
  }
  update(camera) {
    this.colorTarget.update(camera);
  }
  async updatePbuf() {
    await this.colorTarget.updatePbuf();
  }
  render() {
    this.colorTarget.fresh = false;
  }
}
const colorTargetSize = 256;
const raycastCamera = new THREE.OrthographicCamera(
  width_ortho  / -2, width_ortho   /  2,
  height_ortho /  2, height_ortho  / -2,
  0.1, 300
);
const xrRaycaster = new XRRaycaster({
  width: colorTargetSize,
  height: colorTargetSize,
  renderer,
  camera: raycastCamera,
});
const xrMouseRaycaster = new XRRaycaster({
  width: 1,
  height: 1,
  renderer,
  camera: raycastCamera.clone(),
});
class XRChunk {
  constructor(x, y, z) {
    this.object = new THREE.Object3D();
    this.object.position.set(x, y, z);
    container.add(this.object);

    const potentialsTexture = new THREE.DataTexture(null, (width+1)*(height+1)*(depth+1), 1, THREE.LuminanceFormat, THREE.FloatType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
    this.potentialsTexture = potentialsTexture;
    const voxelsMaterial = (() => {
      const voxelsVsh = `
        attribute vec3 coord;
        attribute vec2 barycentric;
        uniform sampler2D uPotentialsTex;
        // varying float vPotential;
        varying vec2 vBC;
        varying vec3 vPosition;
        void main() {
          float ux = (coord.x + coord.y*${((width+1)*(depth+1)).toFixed(8)} + coord.z*${(width+1).toFixed(8)} + 0.5) / ${((width+1)*(height+1)*(depth+1)).toFixed(8)};
          vec2 uv = vec2(ux, 0.5);
          float potential = texture2D(uPotentialsTex, uv).r;
          vBC = barycentric;
          if (potential > 0.0) {
            vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
            vPosition = modelViewPosition.xyz;
            gl_Position = projectionMatrix * modelViewPosition;
          } else {
            gl_Position = vec4(0.0);
          }
        }
      `;
      const voxelsFsh = `
        // varying float vPotential;
        varying vec2 vBC;
        varying vec3 vPosition;

        vec3 color = vec3(0.984313725490196, 0.5490196078431373, 0.0);
        vec3 lightDirection = vec3(0.0, 0.0, 1.0);

        float edgeFactor() {
          float f = 0.0;
          if (vBC.x <= 0.02) {
            f = max(1.0, f);
          } else {
            f = max(1.0 - (vBC.x-0.02)/0.02, f);
          }
          if (vBC.x >= 0.98) {
            f = max(1.0, f);
          } else {
            f = max((vBC.x-0.96)/0.02, f);
          }
          if (vBC.y <= 0.02) {
            f = max(1.0, f);
          } else {
            f = max(1.0 - (vBC.y-0.02)/0.02, f);
          }
          if (vBC.y >= 0.98) {
            f = max(1.0, f);
          } else {
            f = max((vBC.y-0.96)/0.02, f);
          }
          return f;
        }

        void main() {
          float barycentricFactor = (0.2 + edgeFactor() * 0.8);
          vec3 xTangent = dFdx( vPosition );
          vec3 yTangent = dFdy( vPosition );
          vec3 faceNormal = normalize( cross( xTangent, yTangent ) );
          float lightFactor = dot(faceNormal, lightDirection);
          gl_FragColor = vec4((0.5 + color * barycentricFactor) * lightFactor, 0.5 + barycentricFactor * 0.5);
          // gl_FragColor = vBC;
          // gl_FragColor.a = 1.0;
          // gl_FragColor = vec4(color, vPotential);
        }
      `;
      return new THREE.ShaderMaterial({
        uniforms: {
          uPotentialsTex: {
            type: 't',
            value: potentialsTexture,
          },
        },
        vertexShader: voxelsVsh,
        fragmentShader: voxelsFsh,
        transparent: true,
        // depthWrite: false,
        extensions: {
          derivatives: true,
        },
      });
    })();
    this.voxelsMaterial = voxelsMaterial;
    const voxelsTexturedMaterial = (() => {
      const voxelsVsh = `
        attribute vec3 coord;
        attribute vec3 positionCenter;
        uniform sampler2D uPotentialsTex;
        uniform sampler2D uCameraTex;
        // varying float vPotential;
        varying vec3 vPosition;
        varying vec4 vColor;
        void main() {
          float ux = (coord.x + coord.y*${((width+1)*(depth+1)).toFixed(8)} + coord.z*${(width+1).toFixed(8)} + 0.5) / ${((width+1)*(height+1)*(depth+1)).toFixed(8)};
          vec2 voxelUv = vec2(ux, 0.5);
          float potential = texture2D(uPotentialsTex, voxelUv).r;
          if (potential > 0.0) {
            vec4 projectionPositionCenter = projectionMatrix * modelViewMatrix * vec4(positionCenter, 1.0);
            vec3 screenPosition = (projectionPositionCenter.xyz/projectionPositionCenter.w)/2.0+0.5;
            vec2 uv = screenPosition.xy;
            vColor = texture2D(uCameraTex, uv);
            // vColor = vec4(1.0, 0.0, 1.0, 1.0);

            vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
            vPosition = modelViewPosition.xyz;
            gl_Position = projectionMatrix * modelViewPosition;
          } else {
            gl_Position = vec4(0.0);
          }
        }
      `;
      const voxelsFsh = `
        uniform sampler2D uCameraTex;
        // varying float vPotential;
        varying vec3 vPosition;
        varying vec4 vColor;

        vec3 lightDirection = vec3(0.0, 0.0, 1.0);

        void main() {
          /* gl_FragColor = vec4(vec3(${localColor.setHex(0xef5350).toArray().join(', ')}), 0.2 + vPotential);
          gl_FragColor = vec4(vec3(1.0), 0.1);
          vec2 uv = vScreenPosition.xy;
          gl_FragColor = texture2D(uCameraTex, uv); */

          vec3 xTangent = dFdx( vPosition );
          vec3 yTangent = dFdy( vPosition );
          vec3 faceNormal = normalize( cross( xTangent, yTangent ) );
          float lightFactor = dot(faceNormal, lightDirection);

          gl_FragColor.rgb = vColor.rgb * lightFactor;
          gl_FragColor.a = 1.0;
        }
      `;
      return new THREE.ShaderMaterial({
        uniforms: {
          uPotentialsTex: {
            type: 't',
            value: potentialsTexture,
          },
          uCameraTex: {
            type: 't',
            value: cameraTarget.texture,
          },
        },
        vertexShader: voxelsVsh,
        fragmentShader: voxelsFsh,
        // transparent: true,
        extensions: {
          derivatives: true,
        },
      });
    })();
    this.voxelsTexturedMaterial = voxelsTexturedMaterial;

    const voxelsMesh = (() => {
      const geometry = voxelsGeometry;
      const material = voxelTextureSwitchWrap.classList.contains('on') ? voxelsTexturedMaterial : voxelsMaterial;
      const mesh = new THREE.Mesh(geometry, material);
      mesh.frustumCulled = false;
      mesh.needsUpload = false;
      mesh.update = potentials => {
        potentialsTexture.image.data = potentials;

        mesh.visible = voxelsSwitchWrap.classList.contains('on');

        mesh.needsUpload = true;
        potentialsTexture.needsUpdate = true;
        potentialsTexture.onUpdate = () => {
          mesh.needsUpload = false;
          potentialsTexture.onUpdate = null;
        };
      };
      return mesh;
    })();
    voxelsMesh.visible = false;
    this.object.add(voxelsMesh);
    this.voxelsMesh = voxelsMesh;

    const marchCubesRenderTarget = new THREE.WebGLRenderTarget(marchCubesTexSize, marchCubesTexSize, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      // type: THREE.FloatType,
      depthBuffer: true,
      stencilBuffer: false,
    });

    const marchCubesTexturedMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uMarchCubesTex: {
          type: 't',
          value: marchCubesRenderTarget.texture,
        },
      },
      vertexShader: `\
        attribute vec3 barycentric;
        attribute vec2 uv2;
        varying vec2 vUv;
        void main() {
          vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * modelViewPosition;
          vUv = uv2;
        }
      `,
      fragmentShader: `\
        uniform sampler2D uMarchCubesTex;
        varying vec2 vUv;

        void main() {
          gl_FragColor = texture2D(uMarchCubesTex, vUv);
          gl_FragColor.rgb += 0.2;
          gl_FragColor.a = 1.0;
        }
      `,
      // side: THREE.BackSide,
      /* polygonOffset: true,
      polygonOffsetFactor: -1,
      polygonOffsetUnits: -4, */
      transparent: true,
    });
    this.marchCubesTexturedMaterial = marchCubesTexturedMaterial;
    const marchCubesMesh = (() => {
      const geometry = new THREE.BufferGeometry();
      const material = meshingTextureSwitchWrap.classList.contains('on') ? marchCubesTexturedMaterial : marchCubesMaterial;
      const mesh = new THREE.Mesh(geometry, material);
      mesh.scale.set(1, 1, 1).multiplyScalar(voxelSize);
      mesh.frustumCulled = false;
      mesh.visible = false;
      mesh.needsUpload = false;
      mesh.update = (positions, barycentrics, uvs, uvs2) => {
        if (positions.length > 0) {
          const positionsAttribute = new THREE.BufferAttribute(positions, 3);
          geometry.setAttribute('position', positionsAttribute);
          geometry.setAttribute('barycentric', new THREE.BufferAttribute(barycentrics, 3));
          geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
          geometry.setAttribute('uv2', new THREE.BufferAttribute(uvs2, 2));

          mesh.needsUpload = true;
          positionsAttribute.onUploadCallback = () => {
            mesh.needsUpload = false;
            positionsAttribute.onUploadCallback = null;
          };

          mesh.visible = meshingSwitchWrap.classList.contains('on');

          if (meshingTextureSwitchWrap.classList.contains('on')) {
            const unhideUiMeshes = _hideUiMeshes();

            renderer.setRenderTarget(marchCubesRenderTarget);
            renderer.autoClear = false;
            renderer.render(marchCubesRenderScene, camera);
            renderer.autoClear = true;

            unhideUiMeshes();
            renderer.setRenderTarget(null);
          }
        } else {
          mesh.visible = false;
        }
      };
      return mesh;
    })();
    marchCubesMesh.visible = false;
    this.object.add(marchCubesMesh);
    this.marchCubesMesh = marchCubesMesh;

    const marchCubesRenderMesh = (() => {
      const {geometry} = marchCubesMesh;
      const material = marchCubesRenderMaterial;
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(this.object.position);
      mesh.scale.copy(marchCubesMesh.scale);
      mesh.frustumCulled = false;
      return mesh;
    })();
    const marchCubesRenderScene = new THREE.Scene();
    marchCubesRenderScene.add(marchCubesRenderMesh);
  }
  getCenter(v = new THREE.Vector3()) {
    return v.copy(this.object.position).add(new THREE.Vector3(0.5, 0.5, 0.5));
  }
  update(potentials, positions, barycentrics, uvs, uvs2) {
    this.voxelsMesh.update(potentials);
    this.marchCubesMesh.update(positions, barycentrics, uvs, uvs2);
  }
  destroy() {
    this.potentialsTexture.dispose();
    this.marchCubesMesh.geometry.dispose();
    this.voxelsMaterial.dispose();
    this.voxelsTexturedMaterial.dispose();
    this.marchCubesTexturedMaterial.dispose();

    container.remove(this.object);
  }
}
class XRChunker {
  constructor() {
    this.chunks = [];
    this.running = false;
    this.arrayBuffer = new ArrayBuffer(2*1024*1024);
  }
  getChunkAt(x, y, z) {
    for (let i = 0; i < this.chunks.length; i++) {
      const chunk = this.chunks[i];
      const dx = x - chunk.object.position.x;
      const dy = y - chunk.object.position.y;
      const dz = z - chunk.object.position.z;
      if (dx >= 0 && dx < 1 && dy >= 0 && dy < 1 && dz >= 0 && dz < 1) {
        return chunk;
      }
    }
    return null;
  }
  hideChunks() {
    const unhideXrChunks = this.chunks.map(chunk => {
      const oldVoxelsMeshVisible = chunk.voxelsMesh.visible;
      chunk.voxelsMesh.visible = false;
      const oldMarchCubesMeshVisible = chunk.marchCubesMesh.visible;
      chunk.marchCubesMesh.visible = false;
      return () => {
        chunk.voxelsMesh.visible = oldVoxelsMeshVisible;
        chunk.marchCubesMesh.visible = oldMarchCubesMeshVisible;
      };
    });
    return () => {
      for (let i = 0; i < unhideXrChunks.length; i++) {
        unhideXrChunks[i]();
      }
    };
  }
  updateCamera(camera) {
    const _floorVector = v => new THREE.Vector3(Math.floor(v.x), Math.floor(v.y), Math.floor(v.z));
    const cameraCoord = _floorVector(camera.position);
    const cameraCenter = cameraCoord.clone().add(new THREE.Vector3(0.5, 0.5, 0.5));
    const neededCoords = [
      cameraCoord.clone(),
      _floorVector(cameraCenter.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion))),
      // _floorVector(new THREE.Vector3(0, 0, -2).applyQuaternion(camera.quaternion)),
      // _floorVector(new THREE.Vector3(0, 0, -3).applyQuaternion(camera.quaternion)),
    ];
    for (let z = -1; z >= -1; z--) {
      for (let x = -1; x <= 1; x++) {
        for (let y = 1; y >= -1; y--) {
          if (x === 0 && y === 0) {
            continue;
          } else {
            const c = _floorVector(cameraCenter.clone().add(new THREE.Vector3(x, y, z).normalize().applyQuaternion(camera.quaternion)));
            if (!neededCoords.some(c2 => c2.equals(c))) {
              neededCoords.push(c);
            }
          }
        }
      }
    }
    const missingChunkCoords = neededCoords.filter(c => !this.getChunkAt(c.x, c.y, c.z));
    const outrangedChunks = this.chunks.filter(chunk => chunk.object.position.distanceTo(cameraCoord) >= 3.75);
    for (let i = 0; i < outrangedChunks.length; i++) {
      const chunk = outrangedChunks[i];
      this.chunks.splice(this.chunks.indexOf(chunk), 1);
      chunk.destroy();
    }
    for (let i = 0; i < missingChunkCoords.length; i++) {
      const c = missingChunkCoords[i];
      this.chunks.push(new XRChunk(c.x, c.y, c.z));
    }
  }
  async update() {
    if (!this.running) {
      this.running = true;

      xrRaycaster.update(camera);
      await xrRaycaster.updatePbuf();

      // console.log('update 1');
      const chunks = this.chunks.slice();
      const chunkCoords = chunks.map(chunk => chunk.object.position.toArray());
      const res = await worker.request({
        method: 'computeGeometry',
        chunkCoords,
        colorTargetCoordBuf: xrRaycaster.getPointCloudBuffer(),
        colorTargetSize: xrRaycaster.width,
        voxelSize,
        marchCubesTexSize,
        marchCubesTexSquares,
        marchCubesTexTriangleSize,
        arrayBuffer: this.arrayBuffer,
      }, [this.arrayBuffer]);
      const {potentialsArray, positionsArray, barycentricsArray, uvsArray, uvs2Array, arrayBuffer, size} = res;
      this.arrayBuffer = arrayBuffer;
      if (size > arrayBuffer.byteLength) {
        throw new Error(`geometry buffer overflow: have ${arrayBuffer.byteLength}, need ${size}`);
      }

      for (let i = 0; i < chunks.length; i++) {
        chunks[i].update(potentialsArray[i], positionsArray[i], barycentricsArray[i], uvsArray[i], uvs2Array[i]);
      }
      this.updatePromise = _makePromise();
      await this.updatePromise;

      this.running = false;
    }
  }
  render() {
    if (this.updatePromise) {
      this.updatePromise.accept();
      this.updatePromise = null;

      for (let i = 0; i < this.chunks.length; i++) {
        const chunk = this.chunks[i];
        const {potentialsTexture, voxelsMesh, marchCubesMesh} = chunk;
        if (voxelsMesh.needsUpload) {
          potentialsTexture.image.data = null;
        }
        if (marchCubesMesh.needsUpload) {
          marchCubesMesh.geometry.deleteAttribute('position');
          marchCubesMesh.geometry.deleteAttribute('barycentric');
          marchCubesMesh.geometry.deleteAttribute('uv');
          marchCubesMesh.geometry.deleteAttribute('uv2');
        }
      }
    }
  }
}
const xrChunker = new XRChunker();

/* const _makeRenderTargetPlaneMesh = map => {
  const geometry = new THREE.PlaneBufferGeometry(0.5, 0.5);
  const material = new THREE.MeshBasicMaterial({
    map,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
}; */

const raycastTarget = new THREE.WebGLRenderTarget(1, 1, {
  minFilter: THREE.LinearFilter,
  magFilter: THREE.NearestFilter,
  format: THREE.RGBAFormat,
  type: THREE.FloatType,
  depthBuffer: true,
  stencilBuffer: false,
});

const raycastMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(0.05, 0.05, 0.05);
  const material = new THREE.MeshPhongMaterial({
    color: 0xFF0000,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
raycastMesh.visible = false;
container.add(raycastMesh);

const particlesMesh = (() => {
  const cubeGeometry = new THREE.BoxBufferGeometry(0.01, 0.01, 0.01).toNonIndexed();
  const positions = new Float32Array(cubeGeometry.attributes.position.array.length*xrRaycaster.width*xrRaycaster.height);
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const material = new THREE.MeshBasicMaterial({
    color: 0x00FFFF,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = async () => {
    xrRaycaster.update(camera);
    await xrRaycaster.updatePbuf();

    const pointCloudBuffer = xrRaycaster.getPointCloudBuffer();
    let index = 0;
    let baseIndex = 0;
    for (let x = 0; x < xrRaycaster.width; x++) {
      for (let y = 0; y < xrRaycaster.height; y++) {
        const newCubeGeometry = cubeGeometry.clone()
          .applyMatrix(localMatrix.makeTranslation(pointCloudBuffer[baseIndex], pointCloudBuffer[baseIndex+1], pointCloudBuffer[baseIndex+2]));
        positions.set(newCubeGeometry.attributes.position.array, index*newCubeGeometry.attributes.position.array.length);
        index++;
        baseIndex += 3;
      }
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  };
  return mesh;
})();
particlesMesh.visible = cpuSwitchWrap.classList.contains('on');
container.add(particlesMesh);

const gpuParticlesMeshMaterial = (() => {
  const depthVsh = `
    // uniform float uAnimation;
    // attribute float typex;
    // varying vec3 vPosition;
    uniform mat4 uMatrixWorld;
    uniform mat4 uProjectionMatrixInverse;
    uniform vec3 uDirection;
    uniform sampler2D uDepthTex;
    uniform float uNear;
    uniform float uFar;
    float DecodeFloatRGBA( vec4 rgba ) {
      return dot( rgba, vec4(1.0, 255.0, 255.0*255.0, 255.0*255.0*255.0) );
    }
    void main() {
      float xFactor = uv.x;
      float yFactor = uv.y;
      float z = DecodeFloatRGBA(texture2D(uDepthTex, vec2(xFactor, 1.0-yFactor)));

      vec2 coords = vec2(xFactor * 2. - 1., -yFactor * 2. + 1.);
      vec3 origin = (uMatrixWorld * uProjectionMatrixInverse * vec4(coords.x, coords.y, ( uNear + uFar ) / ( uNear - uFar ), 1.0)).xyz;
      vec3 direction = uDirection;

      vec3 p = position + origin + direction * z;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
    }
  `;
  const depthFsh = `
    vec4 EncodeFloatRGBA( float v ) {
      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
      enc = fract(enc);
      // enc -= enc.xyzw * vec4(1.0/255.0,1.0/255.0,1.0/255.0,1.0/255.0);
      return enc;
    }
    // const float infinity = 1./0.;
    void main() {
      gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    }
  `;
  return new THREE.ShaderMaterial({
    uniforms: {
      uMatrixWorld: {
        type: 'm4',
        value: new THREE.Matrix4(),
      },
      uProjectionMatrixInverse: {
        type: 'm4',
        value: new THREE.Matrix4(),
      },
      uDirection: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uNear: {
        type: 'f',
        value: 0,
      },
      uFar: {
        type: 'f',
        value: 1,
      },
      uDepthTex: {
        type: 't',
        value: null,
      },
    },
    vertexShader: depthVsh,
    fragmentShader: depthFsh,
    // transparent: true,
  });
})();
const gpuParticlesMesh = (() => {
  const cubeGeometry = new THREE.BoxBufferGeometry(0.01, 0.01, 0.01).toNonIndexed();
  const positions = new Float32Array(cubeGeometry.attributes.position.array.length*xrRaycaster.width*xrRaycaster.height);
  const numVecs = cubeGeometry.attributes.position.array.length/3;
  const uvs = new Float32Array(numVecs*2*colorTargetSize*colorTargetSize);

  let i = 0;
  for (let x = 0; x < colorTargetSize; x++) {
    for (let y = 0; y < colorTargetSize; y++) {
      const xFactor = x / colorTargetSize;
      const yFactor = y / colorTargetSize;

      positions.set(cubeGeometry.attributes.position.array, i*cubeGeometry.attributes.position.array.length);
      for (let j = 0; j < numVecs; j++) {
        uvs[i*numVecs*2 + j*2] = xFactor;
        uvs[i*numVecs*2 + j*2 + 1] = yFactor;
      }
      i++;
    }
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  const material = gpuParticlesMeshMaterial;
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = () => {
    xrRaycaster.update(camera);

    gpuParticlesMeshMaterial.uniforms.uMatrixWorld.value.copy(xrRaycaster.camera.matrixWorld);
    gpuParticlesMeshMaterial.uniforms.uProjectionMatrixInverse.value.copy(xrRaycaster.camera.projectionMatrixInverse);
    gpuParticlesMeshMaterial.uniforms.uDirection.value.set(0, 0, -1).transformDirection(xrRaycaster.camera.matrixWorld);
    gpuParticlesMeshMaterial.uniforms.uNear.value = xrRaycaster.camera.near;
    gpuParticlesMeshMaterial.uniforms.uFar.value = xrRaycaster.camera.far;
    gpuParticlesMeshMaterial.uniforms.uDepthTex.value = xrRaycaster.getDepthTexture();
  };
  return mesh;
})();
gpuParticlesMesh.visible = gpuSwitchWrap.classList.contains('on');
container.add(gpuParticlesMesh);

/* const textureMesh = _makeRenderTargetPlaneMesh(marchCubesRenderTarget.texture);
textureMesh.position.set(1, 1, 0);
scene.add(textureMesh); */

function DecodeFloatRGBA(rgba, i) {
  /* if (rgba[i] === 0 && rgba[i+1] === 0 && rgba[i+2] === 0 && rgba[3] === 0) {
    return Infinity;
  } else { */
    return rgba[i] +
      rgba[i+1] * 255.0 +
      rgba[i+2] * 255.0*255.0 +
      rgba[i+3] * 255.0*255.0*255.0;
    // return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
  // }
}
window.addEventListener('mousemove', async e => {
  if (raycastSwitchWrap.classList.contains('on')) {
    const rect = renderer.domElement.getBoundingClientRect();
    const xFactor = (e.clientX - rect.left) / rect.width;
    const yFactor = (e.clientY - rect.top) / rect.height;

    const point = await xrMouseRaycaster.raycast(xFactor, yFactor);
    if (point) {
      raycastMesh.position.fromArray(point);
      raycastMesh.visible = true;
    } else {
      raycastMesh.visible = false;
    }
  }
});

setInterval(() => {
  if (gpuSwitchWrap.classList.contains('on')) {
    gpuParticlesMesh.update();
  }
  if (cpuSwitchWrap.classList.contains('on')) {
    particlesMesh.update();
  }
  xrChunker.updateCamera(camera);
  xrChunker.update();
}, 50);

const _hideUiMeshes = () => {
  const oldRaycastMeshVisible = raycastMesh.visible;
  raycastMesh.visible = false;
  const oldParticlesMeshVisible = particlesMesh.visible;
  particlesMesh.visible = false;
  const oldGpuParticlesMeshVisible = gpuParticlesMesh.visible;
  gpuParticlesMesh.visible = false;
  const unhideXrChunker = xrChunker.hideChunks();
  // const oldTextureMeshVisible = textureMesh.visible;
  // textureMesh.visible = false;

  return () => {
    raycastMesh.visible = oldRaycastMeshVisible;
    particlesMesh.visible = oldParticlesMeshVisible;
    gpuParticlesMesh.visible = oldGpuParticlesMeshVisible;
    unhideXrChunker();
    // textureMesh.visible = oldTextureMeshVisible;
  };
};
const _renderDepth = (target, camera) => {
  const unhideUiMeshes = _hideUiMeshes();

  scene.overrideMaterial = depthMaterial;
  depthMaterial.uniforms.uNear.value = camera.near;
  depthMaterial.uniforms.uFar.value = camera.far;
  renderer.setRenderTarget(target);
  renderer.setClearColor(localColor.set(0, 0, 0), 1);
  renderer.render(scene, camera);
  scene.overrideMaterial = null;
  renderer.setClearColor(localColor.set(0, 0, 0), 0);

  unhideUiMeshes();

  renderer.setRenderTarget(null);
};
function animate(timestamp, frame, referenceSpace) {
  if (meshingTextureSwitchWrap.classList.contains('on') || voxelTextureSwitchWrap.classList.contains('on')) {
    const unhideUiMeshes = _hideUiMeshes();

    renderer.setRenderTarget(cameraTarget);
    renderer.render(scene, camera);

    unhideUiMeshes();
    renderer.setRenderTarget(null);
  }

  renderer.render(scene, camera);
  xrChunker.render();
  xrRaycaster.render();
}
renderer.setAnimationLoop(animate);
    </script>
  </body>
</html>
